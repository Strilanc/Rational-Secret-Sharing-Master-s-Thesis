interface SharedSecret
    val Threshold as int
    invariant Threshold >= 0
    int combine(List(int) shares)
        requires shares.size() >= Threshold
end interface

class Commitment
    val Hash as int
    val Salt as int
    func Matches(int v) as bool
        return hash(v + me.Salt) == me.Hash
end class
class Share
    val Key as KeyPair
    val Nonce as int
    val Masks as List(int)
    val PublicKeys as List(int)
end class

#Augments secret shares with the capability to be used by rational players
func RationalizeShares(List(int) shares, fraction finishChancePerRound, impure PRNG prng) as List(Share)
    val numPlayers = shares.size()
    
    # each round must have an equal probability of being the final round
    val targetRound = prng.NextPoisson(finishChancePerRound)
    
    # random seeds for each player's prng
    val keys = new CappedList(KeyPair, capacity: numPlayers)
    for i in numPlayers.Range()
        keys.Append(prng.NextKeyPair())
        continue
      
    # only the target round will unmask players' actual shares
    val nonce = prng.NextInt()
    val masks = keys.zip(shares).map($kkey.PrivateEncrypt(targetRound + nonce) xor $share)
    
    val publicKeys = keys.map($k.PublicKey)
    
    # give players their rational shares
    return keys.map(new RationalShare(
        Key: $key,
        Nonce: nonce,
        Masks: masks,
        PublicKeys: publicKeys))

# The per-player protocol for rationally sharing secrets
func ShareWithOtherPlayers(share as SecretShare, network as Network, secret as Commitment, others as List(player)) as int throws InvalidShares, MissingShares
    for round in Naturals
        # share this round's secret shares
        val dataToSend = share.Key.PrivateEncrypt(round + share.Nonce)
        val received = network.SimultaneousBroadcast(dataToSend, others)
        
        for sender,data,key in received.zip(others):
            if r is none or data.PublicDecrypt(key) != round + share.Nonce then
                others.Remove(sender)
            end if
            continue
            
        List(int) shares = received.zip(share.Masks).map($data xor $mask)
        int candidateSecret = combine shares
        if secret.matches(candidateSecret) then return candidateSecret
        continue
    throw new Defect("Unreachable")

